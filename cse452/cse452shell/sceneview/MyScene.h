#ifndef _MY_SCENE_H_
#define _MY_SCENE_H_

#include "cse452.h"
#include "Color.h"
#include "camera/Camera.h"
#include "../shapes/ShapesUI.h"
#include "parser.h"
#include "Light.h"
#include <FL/Fl_Image.H>
#include <string>
#include <vector>
#include <unordered_map>
using namespace std;
/*
 * This class holds all of the data in the scene file.
 *  Camera
 *  Lights
 *  Subgraphs
 *  Root subgraph
 */

// ToDo: Define these
class Object;
class Node {
public:
	vector <Node *> aChildren;  // children pointers, Array is a List type
	Matrix4 matrix;
	void Draw(const Matrix4 &) const; // Draw me, then my children
	void AddNode(Node *);
	//void ClearTree(Node *);
	virtual void flatten(Matrix4, vector<Object>*) = 0;
};

class Object : public Node{
public:
	enum TYPE {CUBE, CYLINDER, CONE, SPHERE};
	//bool processed;
	Color diffuse, specular, ambient, reflect, transparent, emitted;
	double shine, ior;
	double textureU, textureV;
	string texture;
	shared_ptr<Shape> shape;
	int shape_type;
	void flatten(Matrix4, vector<Object>*);
};

class Tree :public Node {
	void flatten(Matrix4, vector<Object>*);
};

class Trans : public Node {
public:
	void flatten(Matrix4, vector<Object>*);
	Matrix4 matrix;   // Accumulated matrix
};


class MyScene {
public:
    MyScene();
    ~MyScene();
	unordered_map<string, Node*> map;
	vector <Object> objList;
	// two useless lists, only to be deleted later to prevent memory leak.
	vector<Trans*> transList;
	vector<Object*> ptrList;
	double progress;
	bool rendering;
    // The start of the parsing routine
    // Called once when a new scene file is opened
    bool loadSceneFile(std::string filename);
	//void fl
    // Return the current error mesage (if any) generated by parsing
    std::string getErrorMessage() const;

    // Return the parsed camera
    Camera &changeCamera();

    // Return the parsed camera
    const Camera &getCamera() const;

    // Return the parsed camera
    const Color &getBackground() const;

    // Called when the window is re-sized
    void resize(int w, int h);
    // Called when the window needs to be re-drawn
    // Stub can be found in sceneview/MyScene_draw.cpp
    void draw();
    
    /* 
     * The following are for the user interaction assignment 
     * Stubs for them can be found in Interactive/MySceneSelect.cpp
     */
    // User clicked on the screen; find the corresponding shape
    bool selectNode(int x, int y);
    //
    void moveSelectedNode( const Matrix4 &matChange );
    
    /*
     * The following are for the ray tracing assignment
     * Stubs for them can be found in rendering/MyScene_render.cpp
     */
    // 
    void render(int type, int width, int height, unsigned char* pixels);
    void stopRender();
    double getRenderProgress();
	void putPixel(int, int, int, int, Color &, unsigned char* );
	void rayIntersect(Point3, Vector3 , Point3& , Vector3& , Object *&);
	Color calcDiff(Object*, Point3, Vector3, Light*);
	Color calcSpec(Object*, Vector3, Point3, Vector3, Light*);
	Color calcColors(Point3, Vector3, int); //return final color

    /*
     * The following are for the sceneview assignment
     * They can be found in sceneview/MyScene.cpp
     */
    // Clear out any existing data
    void resetScene();

    // Gets the background color from the scenefile
    bool parseBackground(Parser& p);

    // Gets the camera info (if any) from the scene file
    bool parseCamera(Parser& p);

    // Gets the light info (if any) from the scene file
    bool parseLight(Parser& p);
	

    /*
     * The following are the parsing routines you need to finish filling in.
     * Feel free to change the return type or pass in additional parameters.
     */
    // Called when subgraph _name_ [ is encountered in the scene file
    // Should return true when root subgraph encountered
    Tree* parseMasterSubgraph(Parser& p);

    // Called when trans [ is encountered
    Trans* parseTrans(Parser& p);

    // Called when Object _name_ [ is encountered
    Object* parseObject(Parser& p);
  
private:
    // Has loadSceneFile been called yet?
    bool isLoaded;
    // Keep track of the current error message
    std::string errorMessage;
    
    // Store camera info; remember that your default camera should be
    // set to reasonable values in case there is no camera information
    // in the scene file
    Camera camera;

    // Stores the background color found in the scenefile (if any).
    // Defaults to black
    Color background;

    // The stored lights
    Color ambientLight;
    std::vector<Light> lights;

    // your functions/variables go here
};

#endif /* _MY_SCENE_H_ */
